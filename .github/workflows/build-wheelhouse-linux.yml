name: Build Linux wheelhouse

# Least-privilege for GITHUB_TOKEN (explicit permissions avoids inheriting broader defaults).
permissions:
  contents: read

on:
  workflow_dispatch:
  pull_request:
    branches-ignore:
      - "archive/**"
      - "Archive/**"

jobs:
  build-wheelhouse:
    runs-on: ubuntu-latest
    # Needed for checkout/fetch (contents: read) and artifact upload (actions: write).
    permissions:
      contents: read
      actions: write
    
    strategy:
      # NOTE:
      # - pyproject.toml currently sets Black and Ruff target-version to "py311".
      # - Python 3.12 and 3.13 builds are treated as experimental for now; full
      #   lint/format coverage is only guaranteed for Python 3.11.
      matrix:
        python-version: ["3.11", "3.12", "3.13"]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Detect Python and platform tags
        id: detect-tags
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import sys
          import sysconfig
          import os
          
          # Get Python version tag (e.g., py311, py312, py313)
          version_info = sys.version_info
          py_tag = f"py{version_info.major}{version_info.minor}"
          
          # Get platform tag (e.g., linux_x86_64, linux_aarch64)
          platform = sysconfig.get_platform().replace('-', '_').replace('.', '_')
          
          # Write to GitHub output (overwrite for this step to avoid duplicate entries on retry)
          with open(os.environ['GITHUB_OUTPUT'], 'w') as f:
            f.write(f"python_tag={py_tag}\n")
            f.write(f"platform_tag={platform}\n")
          
          print(f"[wheelhouse] python_tag={py_tag}")
          print(f"[wheelhouse] platform_tag={platform}")
          PY

      - name: Prepare wheelhouse requirements (filtered)
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import re
          from pathlib import Path

          src = Path('requirements.lock')
          if not src.exists():
            raise SystemExit('[wheelhouse] requirements.lock not found in repo root')

          raw = src.read_bytes()
          # requirements.lock may be UTF-16LE (common on Windows). Decode robustly.
          if raw.startswith(b'\xff\xfe') or raw.startswith(b'\xfe\xff'):
            text = raw.decode('utf-16')
          elif raw.startswith(b'\xef\xbb\xbf'):
            text = raw.decode('utf-8-sig')
          else:
            try:
              text = raw.decode('utf-8')
            except UnicodeDecodeError:
              text = raw.decode('utf-16')

          lines = text.splitlines()

          # Keep only pinned requirements of the form name==version.
          # Exclude direct URL/path requirements (e.g. "genesis-core @ file://...")
          pinned = []
          for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
              continue
            # Skip direct references (PEP 508 style), both spaced and unspaced: "pkg @ url" / "pkg@url".
            if '@' in line:
              continue
            if re.match(r'^[A-Za-z0-9_.-]+==[^=].+$', line):
              pinned.append(line)

          out = Path('_wheelhouse_requirements_filtered.txt')
          out.write_text('\n'.join(pinned) + '\n', encoding='utf-8')
          print(f'[wheelhouse] wrote {out} with {len(pinned)} pinned lines')
          PY

      - name: Download pinned wheels (binary-only)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p wheelhouse
          python -m pip install --upgrade pip setuptools wheel
          python -m pip download \
            --dest wheelhouse \
            --only-binary=:all: \
            --progress-bar off \
            --requirement _wheelhouse_requirements_filtered.txt

      - name: Ensure dev+ml extras are present (binary-only)
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import tomllib
          import re
          from pathlib import Path

          _NAME_RE = re.compile(r"^[A-Za-z0-9_.-]+")

          def _canonicalize_name(name: str) -> str:
            # PEP 503-ish normalization: collapse runs of -_. to '-'
            return re.sub(r"[-_.]+", "-", name).lower()

          def _name_from_spec(spec: str) -> str | None:
            # Extract the distribution name from an optional-dependencies entry.
            # Handles e.g. "pytest>=7", "mcp", "foo[bar]>=1.0; python_version>'3.10'".
            m = _NAME_RE.match(spec.strip())
            if not m:
              return None
            return _canonicalize_name(m.group(0))

          _WHEEL_VERSION_RE = re.compile(r"^\d+(?:\.\d+)+")

          def _dist_from_wheel_filename(filename: str) -> str | None:
            """Best-effort extraction of dist name from a wheel filename.

            Wheel: {dist}-{version}(-{build})?-{py}-{abi}-{platform}.whl
            Dist itself may contain dashes.
            """
            if not filename.endswith('.whl'):
              return None
            stem = filename[:-4]
            parts = stem.split('-')
            if len(parts) < 5:
              return None
            version_or_build = parts[-4]
            # If parts[-4] looks like a version, assume no build tag.
            if _WHEEL_VERSION_RE.match(version_or_build):
              dist = '-'.join(parts[:-4])
            else:
              # Otherwise assume we have a build tag and version sits at -5.
              if len(parts) < 6:
                return None
              dist = '-'.join(parts[:-5])
            return _canonicalize_name(dist)

          pyproject = Path('pyproject.toml')
          data = tomllib.loads(pyproject.read_text(encoding='utf-8'))
          opt = (data.get('project', {}) or {}).get('optional-dependencies', {}) or {}

          wanted = set()
          for extra in ('dev', 'ml'):
            for spec in opt.get(extra, []):
              name = _name_from_spec(spec)
              if name:
                wanted.add(name)

          # Always include build tools in wheelhouse.
          wanted.update({_canonicalize_name(n) for n in ('pip', 'setuptools', 'wheel')})

          wh = Path('wheelhouse')
          present = set()
          for p in wh.glob('*.whl'):
            dist = _dist_from_wheel_filename(p.name)
            if dist:
              present.add(dist)

          missing = sorted(wanted - present)
          print(f'[wheelhouse] extras/dev+ml unique={len(wanted)} present={len(present)} missing={len(missing)}')

          req = Path('_wheelhouse_extras_missing.txt')
          req.write_text('\n'.join(missing) + '\n', encoding='utf-8')
          print(f'[wheelhouse] wrote {req}')
          for name in missing:
            print(f'[wheelhouse] missing={name}')
          PY

          if [ -s _wheelhouse_extras_missing.txt ]; then
            python -m pip download \
              --dest wheelhouse \
              --only-binary=:all: \
              --progress-bar off \
              --requirement _wheelhouse_extras_missing.txt
          fi

      - name: Verify wheelhouse
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          from pathlib import Path

          wh = Path('wheelhouse')
          wheels = sorted(wh.glob('*.whl'))
          print(f'[wheelhouse] whl_count={len(wheels)}')
          if not wheels:
            raise SystemExit('[wheelhouse] ERROR: wheelhouse is empty')

          def has(prefix: str) -> str:
            return ','.join(p.name for p in wheels if p.name.startswith(prefix + '-'))

          pip_w = has('pip')
          setuptools_w = has('setuptools')
          wheel_w = has('wheel')

          print(f'[wheelhouse] pip_wheels={pip_w}')
          print(f'[wheelhouse] setuptools_wheels={setuptools_w}')
          print(f'[wheelhouse] wheel_wheels={wheel_w}')

          if not pip_w or not setuptools_w or not wheel_w:
            raise SystemExit('[wheelhouse] ERROR: missing pip/setuptools/wheel wheels')
          PY

      - name: Create zip (wheelhouse/ inside)
        shell: bash
        env:
          PYTHON_TAG: ${{ steps.detect-tags.outputs.python_tag }}
          PLATFORM_TAG: ${{ steps.detect-tags.outputs.platform_tag }}
        run: |
          set -euo pipefail
          python - << 'PY'
          import os
          import zipfile
          from pathlib import Path

          wh = Path('wheelhouse')
          python_tag = os.environ['PYTHON_TAG']
          platform_tag = os.environ['PLATFORM_TAG']
          run_id = os.environ.get('GITHUB_RUN_ID', 'local')
          out = Path(f"genesis-core-wheelhouse_{python_tag}_{platform_tag}_{run_id}.zip")

          with zipfile.ZipFile(out, 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=6) as z:
            for p in sorted(wh.glob('*.whl')):
              z.write(p, arcname='wheelhouse/' + p.name)

          with zipfile.ZipFile(out, 'r') as z:
            names = z.namelist()
            ok = any(n.startswith('wheelhouse/') for n in names)
            print(f'[wheelhouse] zip_path={out.resolve()}')
            print(f'[wheelhouse] zip_entries={len(names)}')
            print(f'[wheelhouse] zip_has_wheelhouse_dir={ok}')
            if not ok:
              raise SystemExit('[wheelhouse] ERROR: zip does not contain wheelhouse/ entries')
          PY

      - name: Upload wheelhouse zip
        uses: actions/upload-artifact@v4
        with:
          name: wheelhouse-linux-${{ steps.detect-tags.outputs.python_tag }}
          path: genesis-core-wheelhouse_${{ steps.detect-tags.outputs.python_tag }}_${{ steps.detect-tags.outputs.platform_tag }}_*.zip
          if-no-files-found: error
